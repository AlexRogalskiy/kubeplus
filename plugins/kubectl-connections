#!/bin/bash

print_help () {
    echo "NAME"
    echo "        kubectl connections"
    echo ""
    echo "SYNOPSIS"
    echo "        kubectl connections <Kind> <Instance> <Namespace> [-k <Absolute path to kubeconfig>] [-o json|png|flat] [-i <Kind1:Instance1,Kind1:Instance1>] [-n <label|specproperty|envvariable|annotation>]"
    echo ""
    echo "DESCRIPTION"
    echo "        kubectl connections shows the relationships graph between different Kubernetes resources in a cluster."
    echo "        It take three inputs - the name of the Kubernetes Resource/Kind, the name of the instance of that Kind and the Namespace name."
    echo "        kubectl connections builds the resource graph showing how the provided instance is connected to other"
    echo "        Kubernetes resource instances through various relationships (ownerReference, labels, annotations, spec property)."
    echo "OPTIONS"
    echo "        kubectl connections takes following optional flags as input."
    echo "        -k <Absolute path to kubeconfig file>"
    echo "        -o <json|png|flat>"
    echo "            This flag controls what type of output to generate."
    echo "        -i <Kind1:Instance1,Kind2:Instance2>" 
    echo "            This flag defines which Kinds and instances to ignore when traversing the resource graph."
    echo "            kubectl connections will not discover the sub-graphs starting at such nodes."
    echo "        -n <label|specproperty|envvariable|annotation>"
    echo "            This flag defines the relationship types whose details should not be displayed in the graphical output (png)."
    echo "            You can specify multiple values as comma separated list."
    exit 0
}

check_namespace() {
  local ns=$1
  local kubeconfg=$2
#  ns_output=`kubectl get ns $ns $kubeconfig 2>&1 | awk '{print $1}'`
  ns_output=`kubectl get ns $ns $kubeconfig 2>&1`
  if [[ $ns_output =~ 'Error' ]]; then
     echo "Namespace $ns not found."
     exit 0
  fi
  if [[ $ns_output =~ 'Unable' ]]; then
     echo $ns_output
     exit 0
  fi
}

check_docker() {
  docker ps 2>1 1>/dev/null
  if [[ $? == 1 ]]; then
    echo "Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?."
    echo "Docker is needed for creating png output."
    exit 0
  fi
}

if (( $# < 3 )); then
  print_help
fi

kind=$1
instance=$2
namespace=$3
output="flat"
kubeconfig1="$HOME/.kube/config" #default value
ignorelist1=""
hidedetails=""

shift;
shift;
shift;

#echo $@
while getopts ":k:o:i:n:h" opt; do
  case ${opt} in
    k )
      kubeconfig1=$OPTARG
      if [ ! -f $kubeconfig1 ]; then
        echo "Kubeconfig $kubeconfig1 does not exist."
        exit 0
      fi;;
    o )
      output=$OPTARG
      if [[ $output != 'png' ]] && [[ $output != 'json' ]] && [[ $output != 'flat' ]]; then
          echo "Invalid output type $output. Valid options: flat, json, png."
          exit 0
      fi
      outputString="--output="$output
      ;;
    i )
      ignorelist1=$OPTARG
      ignorelist="--ignore="$ignorelist1;;
    n )
      hidedetails=$OPTARG
      OLDIFS=$IFS
      IFS=','
      read -a hidedetailsarr <<< "$hidedetails"
      for val in "${hidedetailsarr[@]}";
      do
        if [[ $val != "label" ]] && [[ $val != "specproperty" ]] && [[ $val != "envvariable" ]] && [[ $val != "annotation" ]]; then
          echo "Invalid argument value for -n flag. Allowed values are:"
          echo "  label, specproperty, envvariable, annotation."
          echo "  You can specify multiple values as comma separated list."
          exit 0
        fi
      done
      IFS=$OLDIFS;;
    \? ) print_help;;
    h ) print_help;;
    : )
      echo "Invalid option: $OPTARG requires an argument" 1>&2
      ;;
  esac
#  shift $((OPTIND -2))
done

#echo "---"
#echo "$kubeconfig1"
#echo "$output"
#echo "$ignorelist"
#echo "$hidedetails"

kubeconfig="--kubeconfig="$kubeconfig1
check_namespace $namespace $kubeconfig

#canonicalKindPresent=`kubectl api-resources $kubeconfig | grep -w $kind | awk '{print $4}'`
canonicalKindPresent=`kubectl api-resources $kubeconfig | grep -w $kind`
OLDIFS=$IFS
IFS=' '
read -a canonicalKindPresentArr <<< "$canonicalKindPresent"
IFS=$OLDIFS

if [[ "${#canonicalKindPresentArr}" == 0 ]]; then
  echo "Unknown Kind $kind."
  exit 0
fi

# For Kinds in empty API group (like Pods)
a="${canonicalKindPresentArr[2]}" 
if [[ $a == 'true' ]]; then
  canonicalKind="${canonicalKindPresentArr[3]}"
fi

# For Kinds in non-empty API group (like Ingress)
b="${canonicalKindPresentArr[3]}" 
if [[ $b == 'true' ]]; then
  canonicalKind="${canonicalKindPresentArr[4]}"
fi

if [[ "$OSTYPE" == "darwin"* ]]; then
    if [[ "$output" == "png" ]]; then
      check_docker
      /$KUBEPLUS_HOME/plugins/kubediscovery-macos connections $canonicalKind $instance $namespace --output=json $kubeconfig $ignorelist > "$KUBEPLUS_HOME/plugins/connections-op.json"
      docker run -v /$KUBEPLUS_HOME/plugins:/root gcr.io/cloudark-kubeplus/grapher:1.2 connections-op.json /root/ $hidedetails
      echo "Output available in: $KUBEPLUS_HOME/plugins/connections-op.json.gv.png"
    else
      /$KUBEPLUS_HOME/plugins/kubediscovery-macos connections $canonicalKind $instance $namespace $outputString $kubeconfig $ignorelist
    fi
elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
    if [[ "$output" == "png" ]]; then
      check_docker
      /$KUBEPLUS_HOME/plugins/kubediscovery-linux connections $kind $instance $namespace --output=json $kubeconfig $ignorelist > "$KUBEPLUS_HOME/plugins/connections-op.json"
      docker run -v /$KUBEPLUS_HOME/plugins:/root gcr.io/cloudark-kubeplus/grapher:1.2 connections-op.json /root/ $hidedetails
      echo "Output available in: $KUBEPLUS_HOME/plugins/connections-op.json.gv.png"
    else
      /$KUBEPLUS_HOME/plugins/kubediscovery-linux connections $kind $instance $namespace -o $outputString $kubeconfig $ignorelist
    fi
else
    echo "$OSTYPE not supported."
fi
